HLD Final | TEAM Exists As Metonym

https://github.com/bizzlebin/team/blob/master/docs/hld_final.txt

***

By Zachary Wawrzaszek, et al

***

Created on 2020-07-02

Updated on 2020-07-13

+++
1. Introduction

===
1.1. Purpose

The purpose of this project is to provide an application that in return will improve the speed of the process for searching for files on a computers operating system. TagIt.FM is created to assist anyone who has ever had a difficult time locating a specific file within their file manager when they need it urgently, this will provide a very reliable source for any company who is looking for quick results.

The client that TEAM relies on, MHC, is an insurance company and there need for the application is to be able to quickly find the documents needed for the different types of insurance for various file types of the specified OS, which will be used for medical or finanical needs. Customer service representatives, especially, will benefit from the application because it will both simplify the search process and reduce the amount of time they need to keep a customer on hold. This, in turn, can improve the mood of the customer and decrease frustrations for the employee. The purpose of this document is to provide an overview of what will be included in the initial release of the application. The details of the project will be further discussed and developed in the Low-Level Design document.

===
1.2. Scope Of This Document

This document outlines the basic structure of TagIt.FM's interfaces and provides general information about the inner workings of the application which discuss the design methods that will later be implemented. This includes specifications of how the GUI will handle the users requests which then will communicate with the database for the creation, retrieval, editing and deletion of tags. It also discusses how the software will interface with the basic file manager on individual computers of the specified operating system. Details about the design process including issues, tradeoffs, and development and collaboration tools used are also included. Any libraries that were added to Python to assist with the construction of the software are listed in the libraries section. Additionally, it will also discuss the various details the application needs like its architecture, security, hardware, reports and output, database, class structure, and flow of data which are all located on chapter 3.

===
1.3. Definitions, Acronyms, And Abbreviations

**API**: Application programming interface
**ACID**: Atomicity, consistency, isolation, durability
**CLI**: Command line interface
**Class**: A user-defined blueprint or prototype from which all objects are created
**DBMS**: Database management system
**Git**: Distributed version-control system used for tracking source code during software development
**GitHub**: Company that provides hosting for software development version control using Git
**GUI**: Graphical user interface
**HIPAA**: Health Insurance Portability And Accountability Act Of 1996
**HTTP**: Hypertext Transfer Protocol is an application protocol for distributed, collaborative, hypermedia information systems
**HTTPS**: Hypertext transfer protocol secure is an extension of the hypertext transfer protocol that is used for secure communication over a computer network
**IDE**: An integrated development environment, such as PyCharm
**Library**: Reusable code, including functions, that can be used for common programming tasks
**LAN**: Local area network
**Object**: An abstract data type that contain multiple properties and methods, or even other objects as defined by its class
**Python**: An interpreted, high-level, general-purpose programming language
**PyCharm**: An IDE used specifically for the Python programming language
**RDBMS**: Relational database management system
**SDLC**: Software development life cycle
**Slack**: Proprietary business communication platform that features chat and file sharing
**SQL**: Structured query language: a language used in programming that is designed for data held in a relational database management system
**SQLite**: A database that operates directly from library function calls, without a separate process or server
**Tag**: A string without spaces which provides categorical information about its object
**UML**: Unified modeling language
**UEWSG**: Uniform English Writing Style Guide, a set of rules and styles used to codify, standardize, and simplify writing.

+++
2. Design Summary

===
2.1. Overview Of Design

The design of this project will be based around two main classes, the Main Class and the Server_main Class. The Main Class will mostly manage the relationships between the Gui class which has its own Super and sub classes, and the User class which has no inheritances. The Server_main will be in charge of handling the Https_server Class and the database. 

The Main Class will handle interactions between the user inputs and how the GUI will react. The Server_main Class will handle interactions between the Db_helper and Https_server Classes as well as interactions with the database itself to manage the flow of data from the GUI to the database. The Gui class will instantiate objects that inherit class to allow the user to view information about their file hierarchy, tags, and their search history. The User Class is completely independent and is also where the user will interact with these objects to select files, add tags or Remove tags from files, Create new tags or Delete existing tags, and search for files based upon their assigned tags. The GUI will also have a tab available to display reports for the total amount of user, total amount of tags, a demonstration report that shows none of the tags are directly linked to confidential data and a report showing each user and their current level of permissions. 

To access the application the User will need to log in through the GUI with a Username with the given User Type that they are associated with that will be stored in the database, the password will be stored in the database using only salt and hash for authentication purposes. There will be three different levels of users, based on subclasses, where the increased level of user indicates increased privileges and gives them access to more methods that they can execute.

The User Parent Class will have a Username and Password and will be able to add and remove tags from files, as well as search for files based on the assigned tags. The next level of Users Subclass which is called the Mid Level will inherit the previous methods and properties and will, in addition, be able to Create and Delete tags. The highest level of the User class will inherit the mid level class and then becomes a sub class which will be able to create, delete, and promote or demote user access levels. Every User class will have an id assigned to them, which will be used in the process of finding the user to accomplish a task of crud.  The GUI will also communicate through an external interface with the local computer's file manager so that the file hierarchy can be viewed and navigated through within the GUI.

The Db_helper class will reformat incoming and outgoing data so that the data will interact correctly with both the database and the programming language. The class also will handle the creation of database queries in an OOP language, which will be responsible for handling the leg hierarchies data. All data will then be transferred through an HTTPS server for security purposes. The tag database server and the HTTPS server will be controlled by the Https_server Class.

===
2.2. Design Issues

The project originally included many more features that were slowly filtered out as it became clear that there would not be enough time to include all of them in the initial release of TagIt.FM, not only was it a time issue but TEAM needed to organize the requirements to be less impenetrable due to duplications or similarities so it would create space for future versions.

One of the things that was originally planned to be included was a predictive search feature. This feature would allow the application to start searching for files based on what the user had partially typed. Including this feature would have taken extra research and effort and was scrapped to increase focus on the main functionality of the application.

Another feature that was intended to be included was the ability for the user to personalize a color scheme for the GUI and tags. Again, this feature was pushed from the initial release as it is only a quality of life improvement and has no effect on the features that are required for the application to function.

One final example of the few features that were not included in the initial release was including a way for the application to save the currently selected file when the application stops running, whether intentionally or accidentally. This is a quality of life improvement that could save the user a minute every day and is something that may be included in a future update instead of in the first version.

===
2.3. Tools

Slack version four is used as TEAM's primary communication tool. On Slack, group members post updates to their current assignments, ask questions that they may need help with, and discuss plans for future deadlines. Slack is also used to host bi-weekly meetings, which are scheduled and documented on GitHub.

TEAM uses Slack for collaboration and discussion of critical areas of the project. Dedicated channels are set up for discussion, including an LLD channel, an HLD channel, an SRS channel, and a meetings channel. Each channel is intended to primarily discuss matters related to the associated deliverable. Group discussions are held on Slack, and the group collaborates to find solutions to problems as they arise.

The other collaboration tool that TEAM is using is a popular version control system named GitHub. It is used to make updates to files, merge files, and upload files based on the project requirements. Narratives are saved on GitHub in plain text using the extension of .txt and following the UEWSG format. Diagrams and other documents are saved in a format suitable for their purpose.

Each group member has posted their preferred work hours in the availability.txt document on GitHub, based on which meeting times of 8 PM every Tuesday and Thursday were decided. The members of TEAM have tasks and other assignments that are listed in the master branch in the readme document that are added by the project manager.

TEAM will be using PyCharm version 2020.1.2 with the build number 201.7846.77 as its IDE; this is a tool developed by JetBrains for use with the Python programming language. There are other alternatives like using NotePad++ which is an example of a text editor that the TEAM will also be using. The responsibilities of the IDE are to integrate with SQLite, which is the group's chosen database language. The IDE will be used to develop the application when the SDLC is at the development phase and to implement testing procedures within that tool.

===
2.4. Libraries

**http.client**: Defines classes which implement the client side of the HTTP and HTTPS protocols
**ssl**: Provides access to transport layer security encryption and peer authentication facilities for network sockets, both client-side and server-side
**os**: Provides a portable way of using operating system dependent functionality
**tkinter**: Provides a robust platform independent windowing toolkit
path
**sys**: Provides access to some variables used or maintained by the interpreter and to functions that interact strongly with the interpreter
**timeit**: Provides a simple way to time small bits of Python code

+++
3. Design Details

===
3.1. Security

MHC deals with documents and records that must remain confidential due to HIPAA regulations. Therefore, all data transfers will be handled using an HTTPS server, that HTTPS server will then encrypt the data and stop potential intruders from being able to understand any data that they are able to intercept during a transfer to the database that is hosted by the server. The company network runs on a private setup and mandates the use of firewalls when connecting to the internet, which reduces the potential of DDOS attacks or hackers trying to find direct access to the servers. The physical security of the building will provide further protection and deny unauthorized personnel direct access to the network or server.

To provide another layer of security to TagIT.FM, MHC Employees will be provided an account that is based off their responsibilites in the company. Since every user will have the ability to complete tasks in this application, there will be access to log in to a Mid_level User if that employee has the restrictions cut off and can gain access to create or delete tags within TagIT.FM. There also must be direct access to administrate the maintainability of the application, meaning it has a High_level access role that will provide the employee with the ability to create a username and password making the application more secure since the Users information will only be accessed by the High-level and User if the account was meant to be created, or else the Client will create it themselves. It will also provide the ability to delete a Users account when it's neccessary, and update a default User role up or down to a specific role.

By choosing a variety of layers in this application it will in return provide higher security practices that provide the Client with a sense of comfort about how their data is handled. It will also organize the structure to prevent any confusion in power about who handles the higher administrative roles which will not interfere with the daily operations. 

===
3.2. Hardware

Required hardware for this project includes the following: A server that will host the database for handling tags, a private LAN to facilitate communication between the employees computers which will host the GUI for requesting tasks to be completed. Cables and routers will also be necessary to connect the server to the LAN that runs the database of the application. The TagIt.FM application will be able to run on any computer or laptop that is provided for the employees that is connected to the LAN with the required operating system which is windows and linux and specifications that fit the needs of the applications standards which are x86, without these specifications of specific hardware the application will be impractical and provide no use to the user.

===
3.3. User Interfaces

The GUI of TagIt.FM will initialize as a window and can be resized and dragged to where the user wants it. A login screen will appear when the application starts, and the employee must enter their username and password to login to the application.

After a successful login, the GUI will display three separated areas. One side will be a panel where the employee can navigate their file tree and select a folder or file that they want to add or remove tags from. On the other side of the screen, there will be a panel that has all of the available tags that can be used, as well as a search bar to search for a specific tag that the employee wants to use. If the employee has the correct permissions, this is also where they will be able to create new tags and delete existing tags from the database. In the middle of the screen, there will be a search bar where the employee will be able to search for files by entering the associated tags; this is also where the returned files will be displayed.

There will also be a clickable button that will allow the user to access the reports outlined in section 3.7. The GUI will also display the user's username in a small box in the corner of the window so they are able to confirm they are logged in under the correct account. Next to that small box will be a logout button that will allow the user to exit their session and bring them back to the login screen. In the file hierarchy area of the GUI the user will also be able to observe the file creation date and current size of the file as outlined in section 3.8.  

---
3.3.1. TagIt.FM Concept UI Diagram

The following diagram illustrates the basic GUI layout that will be used in the TagIt.FM application. It features the three main panels, including the account login panel, the control panel with a search feature as well as a list of recently used tags, and the folders panel, which shows the currently selected directory. Additionally, there is the main search bar for finding files by their associated tags.

https://github.com/Bizzlebin/TEAM/blob/master/ui_mockup.png

===
3.4. Internal Interfaces

There will be a few internal interfaces at work in TagIt.FM due to several classes needing to pass data back and forth to each other. The Gui Class will be interfacing with the Tags Class to retrieve the list of created tags and add them to the display for the user to see. The Gui Class will also interface with the History Class which will let the Gui Class retrieve a list of the user's recent actions and display them to the user. The Main class will be interfacing with both the User and Gui classes to manage their interactions through the user's choices and actions in the GUI.

The Main class will also create an instance of the Http_client class which will communicate data retrieved from the server side of the network through the Main class to the rest of the classes.

There will also be internal interfaces necessary on the server side of the network. The Server_main class will create instances of both an Https_server Class and a Db_helper class. The Db_helper class is responsible for the encapsulation of data being sent to the database as well as the de-encapsulation of data retrieved from the database that will be sent through the Server_main Class and over the server to the client side. The Https_server class will handle the transfer of data to and from the Http_client Class. The data retrieved from the Main class will be used to update the database whereas the data sent back to the client will be used to update the Tags and History Classes.

===
3.5. External Interfaces

TagIt.FM will feature 2 external interfaces: one on the client side and one on the server side. On the client side, the app will interact with the local filesystem in order to provide an up-to-date listing of the computer's files and directories; this will occur without any filesystem locking or other interference which would infringe upon normal filesystem operations. On the server side, the application will interact with an SQLite database, which will hold everything from the tag information to the user permissions. This interface will be responsible for encapsulating all requests into discrete SQL statements and deencapsulating all responses back into standard datatypes recognized by the app. There will also be pre programmed SQL statements that will allow for the retrieval of the reports outlined in section 3.7.

===
3.6. Architecture

The architecture that will be used for this project is a client/server model. The client will have many different instances of the TagIt.FM GUI open on different employee computers. All these separate instances will be simultaneously communicating over the established company LAN and routed into the database using an HTTPS server. This architecture will support constant updates of the GUI based on any changes made to the data on the server side by a different employee and instance of the program. This ensures that all the information remains constant and reliable for the employees who need to use it.

---
3.6.1. Software Architecture Diagram

This diagram illustrates the client/server model architecture that will be used for the TagIt.FM application. The clients are show on the left, connecting through the LAN to the server on the right side of the diagram.

https://github.com/Bizzlebin/TEAM/blob/master/architecture_diagram.PNG

===
3.7. Reports

Reports will be able to display total count of users and the total count of tags available for use. Another report will also be available that will allow a user to select a tag and it will display all of the files it is associated with that the user could normally access, this will occurr without revealing any confidential information included in those files. A final report that can retrieved will display a database view that allows the user to view each user's current level of permissions.

===
3.8. Other Output

Other information that will be available for the user to view will include the last modified date and current size of the file selected. There will also be a small area to display the current user's username so that they are able to know they are logged in under the correct account.  

===
3.9. Databases

This project only requires the use of one RDBMS for the storage and management of user identification parameters, group permissions, filename and tag relations, and user histories. SQLite works well for MHC because it is a robust and lightweight system that boasts speedy query times which will be important for the customer service representatives who are trying to search for files in the most efficient manner possible. SQLite also offers high portability and will work across a wide variety of operating systems allowing the company to utilize any equipment they already have available. One final benefit of SQLite is that content can be updated continuously and automatically so that in the event of a power outage or crash little to no data will be lost.

===
3.10. Top-Level Classes (Class Hierarchy)

---
3.10.1. Main Class

This class will handle the classes for the client side of the application, it will be a separate class from the Server_main Class. The class will primarily be responsible for handling the five classes that branch off into their own respective hierarchies. It will call the Gui class and handle all interaction between the user inputs and the GUI.

The Main will initially have seven functions that it will use to structure the data for the MHC employees. The init function will initialize the GUI, HTTPS Server, and the user on instantiation, which will then be responsible for creating the next three functions that create the GUI, HTTPS Client and the User objects. This method will be kept private while the rest of the functions will be public so that if an error occurs, or a User logs out and wants to log back in, they can be restarted individually.

The create_gui function will primarily be involved in creating the application's GUI and then updating the associated private variables required for that function. The create_https_client and create_user function the same manner as the create_gui. These three functions will store variables that will be used in by the User superclass and subclasses to handle any tasks, for example, if the User would like to create a file tag in the GUI they can call the create_gui function. The last three functions: read_gui, read_https_client and read_user will primarily be in charge of reading the memory locations of the objects inside the function so information can be gathered.

---
3.10.2. Server_main Class

This class will handle 2 classes and they are the Https_server and DBHelper classes, these do not have any inheritance hierarchies built into the design as of now but future versions may call for subclasses. The number of functions are undetermined but there will be an init function as a standard to this class to handle the instantiation, the DBHelper and the Server objects will be created in this section. There must be a need to create the Https_server and Db_helper functions after creating the objects so that the private variables can be declared.

This main also needs to create functions based on reading the memory locations of the Server and DBHelper objects so that tasks can be completed from the requests coming in. It will handle the data for authentication purposes of the client's requests.

---
3.10.3. Gui Class

This will be the class that contains and displays the objects for the user interface. It will connect with the History class to ensure that the user has access to previously searched tags, and it call the Tags class to update and display tags as the user searches for them. Additionally, the GUI class will communicate with the computer's base file manager through the File_manager_helper class. This allows for the retrieval of the computers entire file hierarchy and that same file hierarchy will be displayed to the user within the GUI so they can navigate through it and select the files they want to tag or interact with. The Gui class will also contain a function that will allow the user to view the reports detailed in section 3.7 in a separate area. The Gui class will also provide information about the creation date and current size of the file selected in the file hierarchy area of the window, as well as displaying the user's username next to the logout function so they can confirm they are logged in under the correct account.  

---
3.10.4. User Class

The basic User class will contain usernames and passwords and will let the employee interact with the GUI. This class will have two subclasses representing the level of the employee, each subclass inheriting from the previous class, and adding its own functions and attributes.

Each level of the user classes will be set up in this format due to the authentication requirements outlined in the SRS document. User accounts will be assigned either as High_user, Mid_user or User, depending on their job duties at MHC. The level of the account will give the employee access to specific functions within the TagIt.FM application, so that they will be able to complete the tasks as required by their role.

The User class will primarily involve seven different functions to create the structure for the remaining two subclasses, they are: init, login, create_file_tag, delete_file_tag, read_file_tags, read_history, and read_id. The init function will handle initializing the user object, which creates the username and password while calling the login function. The login function will be responsible for handling the client's response from sending a request to log in with the given username and password. The create_file_tag, delete_file_tag, and read_file_tags will be designed in a way where the user cannot handle the tasks given to them without authentication, they will then quickly complete their tasks using the given parameters and arguments. The read_history will primarily be responsible for gathering the information from the user's history that stores the actions and the read_id will primarily read the Users ID.

---
3.10.5. Tags Class

This class will be responsible for holding all the created tags and displaying them for the employee. The Tags class will recieve constant updates from the database taking into account any changes that have been made to the availability of specific tags, ensuring that both the database and the Tags Class stay up-to-date.

---
3.10.6. Https_server Class

This class will be used for setting up our server and defining the requests for sending and retrieving data.

---
3.10.7. Db_helper Class

The DBHelper class will be used for reformatting the data from Python to SQL, enabling the data to correctly interact with the database tables. The class will also facilitate the use of Python from within the application to create the SQL functions and statements needed to manipulate the database.

TEAM will implement the normalization of this class according to 3NF standards. Because of this the database will feature less dependencies on the tables that are created, and the tables will be organized to a level where there is no data duplication within them. The Db_helper class will prevent the need for a many-to-many relationship within the database tables, ensuring 3NF is maintained.

This class will also have the responsibility of handling errors that may come across from the application. It will spot dirty data and return a statement requesting any required corrections, ensuring that any redundancies or missing data can be corrected prior to being committed to the database.

---
3.10.8. History Class

This class will hold a list of the user's recent actions, such as creating a tag, adding a tag to a file, or searching for a file by its tags. This class will cooperate with the GUI as one of its other responsibilites mainly because to access the History the User will need to interact with the right pane displayed when the applications UserType is logged in because this is where finding the history of the recent actions will be setup.

---
3.10.9. File_manager_helper Class

This class will be responsible for retrieving the computers file hierarchy from the file manager for display in the GUI.

---
3.10.10. Https_client Class

This class handles the requests and transfers of data to and from the server side of the project architecture. It will utilize both the http.client and ssl libraries to provide secure transfers of data between the client and server. The http.client library provide HTTPS support if the code is compiled using the ssl library. This is accomplished through the ssl library's methods that allow for certificate authentication and its ability to create ssl sockets. 

---
3.10.11. HLD Diagram

The following diagram explains the classes that will implemented during the design phase of the project. It contains two main classes, Client Main and Server Main. The diagram displays the Client Main on the left as being responsible for handling the five classes in its hierarchy: GUI, User, History, Tags, File_manager_helper, and on the right side the Server_main is only responsible for two classes: Https_server and Db_helper.

https://github.com/Bizzlebin/TEAM/blob/master/hld_diagram.png

---
3.10.12. User Authentication Diagram

The Authentication diagram below explains the process of when a Client will login with the User Type that they are given by requesting to logon to the servers that includes the database. The arrows represent that the Client will type in the Username and Password information and inside the loop will validate the name and pass to the servers and check if the Username is inside the database. The arrows switch directions after grabbing the userType inside the database hosted by the server then continue to validate and display the LoginScreen. Alternatively, there are three options displayed under the loop that determine what the userTypes level is and when determined displays the userType.

https://github.com/Bizzlebin/TEAM/blob/master/authentication_diagram.png

===
3.11. Configuration Data

===
3.12. Data Flows And States

---
3.12.1. Data Flow Diagram 1

Data flow diagram 1, illustrates the functions that will be available to the High_user class. This class will be able to change the level of users, in addition to the tag creation and deletion functions inherited from the Mid_user class, and the search function inherited for the User class.

https://github.com/Bizzlebin/TEAM/blob/master/data_flow_diagram1.PNG

---
3.12.2. Data Flow Diagram 2

Data flow diagram 2, illustrates some of the functions that will be available to a user depending on their level, and how they will interact with the database tables. The login function as well as the create/delete user fuctions will interact with the User table. The create/delete tag functions will interact with the Tag table, and the update or clear history functions will interact with the User History table.

https://github.com/Bizzlebin/TEAM/blob/master/data_flow_diagram2.PNG
